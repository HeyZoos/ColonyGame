use std::path::PathBuf;

use bevy::prelude::*;
use bevy_ecs_tilemap::prelude::*;
use grid_2d::{Grid, Size};
use noise::{NoiseFn, Perlin};
use rand::{SeedableRng, thread_rng};
use rand::prelude::SliceRandom;
use rand_chacha::ChaCha8Rng;
use wfc::overlapping::OverlappingPatterns;
use wfc::Wave;

const WIDTH: u32 = 256;
const HEIGHT: u32 = 256;
const TILE_SIZE: f32 = 16.0;

pub struct WorldgenPlugin;

impl Plugin for WorldgenPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(TilemapPlugin);
        app.add_systems(Startup, startup);
        app.add_systems(PostStartup, resource_layer_startup_system);
    }
}

#[derive(Resource)]
pub struct World {
    pub wave: Wave,
    pub patterns: OverlappingPatterns<u16>
}

fn startup(mut commands: Commands, assets: Res<AssetServer>) {
    // Load hand-crafted pattern made in the Tiled editor
    let mut tiled_loader = tiled::Loader::new();

    // Note that this tilemap needs to be a square
    let tiled_map = match tiled_loader.load_tmx_map("assets/patterns.tmx") {
        Ok(map) => map,
        Err(e) => {
            error!("Failed to load Tiled map: {}", e);
            return;
        }
    };

    // For each tilemap layer
    for layer_idx in (0..tiled_map.layers().len()).rev() {
        let layer = tiled_map.layers().nth(layer_idx).unwrap();

        // Convert the layer to a tile layer
        let tile_layer = layer.as_tile_layer().unwrap();

        // Each layer should only reference the master tileset
        let mut tileset = tiled_map.tilesets()[0].as_ref();

        // Convert the tile layer to a Vec<u16> which for wave function collapse
        let mut pattern = vec![];
        for y in (0..tile_layer.height().unwrap()).rev()  {
            for x in 0..tile_layer.width().unwrap() {
                if let Some(tile) = tile_layer.get_tile(x as i32, y as i32) {
                    pattern.push(tile.id() as u16);
                    tileset = tile.get_tileset();
                } else {
                    pattern.push(255);
                }
            }
        }

        // Run wave function collapse
        let wave = wfc(patterns(pattern.clone()), 3);

        // Get the tileset asset
        let tileset_image = tileset.image.as_ref().expect("Image not found");
        let mut tileset_image_path = tileset_image.source.clone();
        tileset_image_path = PathBuf::from(tileset_image_path.strip_prefix("assets").unwrap());
        let texture_handle = assets.load(tileset_image_path);

        // Build tilemap based on WFC results
        let tilemap_size = TilemapSize { x: WIDTH, y: HEIGHT, };
        let tilemap_entity = commands.spawn_empty().id();
        let mut tile_storage = TileStorage::empty(tilemap_size);
        populate_tilemap(&mut commands, &mut tile_storage, &wave, tilemap_entity, patterns(pattern.clone()));

        // Store the wave as a resource for use in pathfinding and post-processing
        // Only store the wave generated by the land / grass layer
        if layer.name == "grass" {
            commands.insert_resource(World { wave, patterns: patterns(pattern.clone()) });
        }

        let tile_size = TilemapTileSize { x: TILE_SIZE, y: TILE_SIZE, };
        let grid_size = tile_size.into();
        let map_type = TilemapType::default();
        commands.entity(tilemap_entity).insert(TilemapBundle {
            grid_size,
            map_type,
            size: tilemap_size,
            storage: tile_storage,
            texture: TilemapTexture::Single(texture_handle),
            tile_size,
            transform: Transform::from_xyz(0.0, 0.0, layer_idx as f32),
            ..Default::default()
        });
    }
}

// Populate Tilemap Function
fn populate_tilemap(
    commands: &mut Commands,
    tile_storage: &mut TileStorage,
    wave: &Wave,
    tilemap_entity: Entity,
    patterns: OverlappingPatterns<u16>
) {
    for coordinate in wave.grid().coord_iter() {
        let cell =  wave.grid().get(coordinate).unwrap();
        let id = cell.chosen_pattern_id().unwrap();
        let value = variants(*patterns.pattern_top_left_value(id));
        let tile_pos = TilePos { x: coordinate.x as u32, y: coordinate.y as u32 };

        let mut tile = commands
            .spawn(TileBundle {
                position: tile_pos,
                texture_index: TileTextureIndex(value as u32),
                tilemap_id: TilemapId(tilemap_entity),
                ..Default::default()
            });

        if value == 128 {
            tile.insert(AnimatedTile {
                start: 128,
                end: 131,
                speed: 0.5
            });
        }

        tile_storage.set(&tile_pos, tile.id());
    }
}

// u16 -> u16
fn variants(tilemap_idx: u16) -> u16 {
    let mut rng = thread_rng();
    // If a value is grass, randomly choose one of the variants
    match tilemap_idx {
        17 => *[
            17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
            17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
            17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, // Weight the plain grass tile more heavily
            85, 96, 97, 98, 99, 100, 101].choose(&mut rng).unwrap() as u16,
        _ => tilemap_idx
    }
}

// Vec<u16> -> OverlappingPatterns<u16>
fn patterns(pattern: Vec<u16>) -> OverlappingPatterns<u16> {
    let sqrt = (pattern.len() as f64).sqrt() as u32;
    let grid = Grid::new_iterator(Size::new(sqrt, sqrt), pattern.into_iter());
    OverlappingPatterns::new(
        grid,
        std::num::NonZeroU32::new(2).unwrap(),
        &[wfc::Orientation::Original]
    )
}

// OverlappingPatterns<u16>, u64 -> Wave
fn wfc(patterns: OverlappingPatterns<u16>, seed: u64) -> Wave {
    let mut rng = ChaCha8Rng::seed_from_u64(seed);
    let global_stats = patterns.global_stats();

    let runner = wfc::RunOwn::new_wrap_forbid(
        Size::new(WIDTH, HEIGHT),
        &global_stats,
        wfc::wrap::WrapNone,
        wfc::ForbidNothing,
        &mut rng,
    );

    runner.collapse_retrying(
        wfc::retry::NumTimes(20),
        &mut rng,
    ).unwrap()
}

fn resource_layer_startup_system(
    mut commands: Commands,
    world: Res<World>,
    assets: Res<AssetServer>
) {
    let perlin = Perlin::new(3);

    // Define noise scale for resource placement
    let noise_scale = 0.1;

    // Get the tileset asset for resources
    let resource_tileset_path = "mushrooms-flowers-stones.png";
    let resource_texture_handle = assets.load(resource_tileset_path);

    // Create a new tilemap for resources
    let resource_tilemap_size = TilemapSize { x: WIDTH, y: HEIGHT, };
    let resource_tilemap_entity = commands.spawn_empty().id();
    let mut resource_tile_storage = TileStorage::empty(resource_tilemap_size);

    // Populate the resource tilemap
    for coord in world.wave.grid().coord_iter() {
        let x = coord.x;
        let y = coord.y;
        let noise_value = perlin.get([x as f64 * noise_scale, y as f64 * noise_scale]);

        // Threshold for placing resource tiles
        if noise_value > 0.3 {
            let tile_pos = TilePos { x: x as u32, y: y as u32 };
            let wave_tile = world.wave.grid().get(coord).unwrap();
            let pattern_id = wave_tile.chosen_pattern_id().unwrap();
            let value = world.patterns.pattern_top_left_value(pattern_id);

            // Check if the current tile is grass
            // We can only spawn resources on grass
            if *value == 17 {
                let resource_tile = commands.spawn(TileBundle {
                    position: tile_pos,
                    texture_index: TileTextureIndex(27), // The bush
                    tilemap_id: TilemapId(resource_tilemap_entity),
                    ..Default::default()
                });
                resource_tile_storage.set(&tile_pos, resource_tile.id());
            }
        }
    }

    let resource_tile_size = TilemapTileSize { x: TILE_SIZE, y: TILE_SIZE, };
    let resource_grid_size = resource_tile_size.into();
    let resource_map_type = TilemapType::default();
    commands.entity(resource_tilemap_entity).insert(TilemapBundle {
        grid_size: resource_grid_size,
        map_type: resource_map_type,
        size: resource_tilemap_size,
        storage: resource_tile_storage,
        texture: TilemapTexture::Single(resource_texture_handle),
        tile_size: resource_tile_size,
        transform: Transform::from_xyz(0.0, 0.0, 5.0),
        ..Default::default()
    });
}
